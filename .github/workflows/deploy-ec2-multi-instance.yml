name: Deploy Resume Website to Multiple EC2 Instances

on:
  push:
    branches: [ main ]
    paths:
      - 'ec2-solution/**'
      - '.github/workflows/deploy-ec2-multi-instance.yml'
  pull_request:
    branches: [ main ]
    paths:
      - 'ec2-solution/**'
      - '.github/workflows/deploy-ec2-multi-instance.yml'
  workflow_dispatch:  # Allow manual triggering
    inputs:
      instance_count:
        description: 'Number of EC2 instances to deploy'
        required: false
        default: '3'
        type: choice
        options:
          - '1'
          - '2'
          - '3'
          - '4'
          - '5'

env:
  AWS_REGION: eu-west-1
  TERRAFORM_VERSION: 1.5.0

jobs:
  deploy-infrastructure:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    outputs:
      bastion_ip: ${{ steps.outputs.outputs.bastion_ip }}
      bastion_sg_id: ${{ steps.outputs.outputs.bastion_sg_id }}
      web_instance_private_ips: ${{ steps.outputs.outputs.web_instance_private_ips }}
      web_instance_public_ips: ${{ steps.outputs.outputs.web_instance_public_ips }}
      instance_count: ${{ steps.outputs.outputs.instance_count }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TERRAFORM_VERSION }}
        terraform_wrapper: false
    
    - name: Package Lambda functions
      working-directory: ./ec2-solution
      run: |
        cd lambda
        zip -r ../terraform/visitor_counter_lambda.zip visitor_counter_lambda.py
        zip -r ../terraform/contact_form_lambda.zip contact_form_lambda.py
        cd ..
        ls -la terraform/*.zip
    
    - name: Terraform Init
      working-directory: ./ec2-solution/terraform
      run: |
        terraform init \
          -backend-config="bucket=terraform-state-resume-website" \
          -backend-config="key=ec2-solution/terraform.tfstate" \
          -backend-config="region=eu-west-1" \
          -backend-config="dynamodb_table=terraform-state-lock"
    
    - name: Terraform Validate
      working-directory: ./ec2-solution/terraform
      run: terraform validate
    
    - name: Set instance count
      id: set_count
      run: |
        if [ "${{ github.event.inputs.instance_count }}" != "" ]; then
          INSTANCE_COUNT="${{ github.event.inputs.instance_count }}"
        else
          INSTANCE_COUNT="3"
        fi
        echo "INSTANCE_COUNT=${INSTANCE_COUNT}" >> $GITHUB_ENV
        echo "instance_count=${INSTANCE_COUNT}" >> $GITHUB_OUTPUT
        echo "Deploying ${INSTANCE_COUNT} instances"
    
    - name: Terraform Plan
      working-directory: ./ec2-solution/terraform
      run: |
        terraform plan -detailed-exitcode \
          -var="ami_id=${{ secrets.TF_AMI_ID }}" \
          -var="bastion_ami_id=${{ secrets.TF_BASTION_AMI_ID }}" \
          -var="domain_name=${{ secrets.TF_DOMAIN_NAME }}" \
          -var="key_name=${{ secrets.TF_KEY_NAME }}" \
          -var="management_cidr=${{ secrets.TF_MANAGEMENT_CIDR }}" \
          -var="public_key_content=${{ secrets.TF_PUBLIC_KEY }}" \
          -var="instance_count=${{ steps.set_count.outputs.instance_count }}"
      continue-on-error: true
      id: plan
    
    - name: Terraform Apply
      working-directory: ./ec2-solution/terraform
      if: github.ref == 'refs/heads/main'
      run: |
        terraform apply -auto-approve \
          -var="ami_id=${{ secrets.TF_AMI_ID }}" \
          -var="bastion_ami_id=${{ secrets.TF_BASTION_AMI_ID }}" \
          -var="domain_name=${{ secrets.TF_DOMAIN_NAME }}" \
          -var="key_name=${{ secrets.TF_KEY_NAME }}" \
          -var="management_cidr=${{ secrets.TF_MANAGEMENT_CIDR }}" \
          -var="public_key_content=${{ secrets.TF_PUBLIC_KEY }}" \
          -var="instance_count=${{ steps.set_count.outputs.instance_count }}"
    
    - name: Get Terraform Outputs
      working-directory: ./ec2-solution/terraform
      id: outputs
      run: |
        echo "bastion_ip=$(terraform output -raw bastion_public_ip)" >> $GITHUB_OUTPUT
        echo "bastion_sg_id=$(terraform output -raw bastion_security_group_id)" >> $GITHUB_OUTPUT
        echo "web_instance_private_ips=$(terraform output -json web_instance_private_ips)" >> $GITHUB_OUTPUT
        echo "web_instance_public_ips=$(terraform output -json web_instance_public_ips)" >> $GITHUB_OUTPUT
        echo "instance_count=$(terraform output -raw instance_count || echo ${{ steps.set_count.outputs.instance_count }})" >> $GITHUB_OUTPUT

  deploy-application:
    needs: deploy-infrastructure
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    # Get the current runner's public IP
    - name: Get runner IP
      id: ip
      uses: haythem/public-ip@v1.2

    # Dynamically whitelist the runner IP
    - name: Whitelist runner IP
      run: |
        echo "Adding runner IP ${{ steps.ip.outputs.ipv4 }} to security group ${{ needs.deploy-infrastructure.outputs.bastion_sg_id }}"
        aws ec2 authorize-security-group-ingress \
          --group-id ${{ needs.deploy-infrastructure.outputs.bastion_sg_id }} \
          --protocol tcp \
          --port 22 \
          --cidr ${{ steps.ip.outputs.ipv4 }}/32
    
    - name: Setup SSH
      run: |
        mkdir -p ~/.ssh
        chmod 700 ~/.ssh
        
        printf '%s\n' "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        
        # Validate SSH key
        ssh-keygen -l -f ~/.ssh/id_rsa && echo "✅ SSH key validation successful" || {
          echo "❌ SSH key validation failed"
          exit 1
        }
    
    - name: Configure SSH connections for all instances
      run: |
        BASTION_IP=${{ needs.deploy-infrastructure.outputs.bastion_ip }}
        
        # Add bastion to known hosts with retry
        for i in {1..3}; do
          echo "Attempt $i: Scanning SSH keys for $BASTION_IP"
          if timeout 30 ssh-keyscan -H $BASTION_IP >> ~/.ssh/known_hosts 2>/dev/null; then
            echo "✅ SSH keyscan successful"
            break
          else
            echo "⚠️ SSH keyscan attempt $i failed, retrying..."
            sleep 10
          fi
          
          if [ $i -eq 3 ]; then
            echo "⚠️ SSH keyscan failed after 3 attempts, proceeding without it"
          fi
        done
        
        # Create SSH config with bastion
        cat > ~/.ssh/config << EOF
        Host bastion
          HostName $BASTION_IP
          User ec2-user
          IdentityFile ~/.ssh/id_rsa
          StrictHostKeyChecking no
          UserKnownHostsFile ~/.ssh/known_hosts
          ConnectTimeout 30
          ServerAliveInterval 60
        EOF
        
        # Add SSH config for all webservers dynamically
        echo '${{ needs.deploy-infrastructure.outputs.web_instance_private_ips }}' | jq -r '.[]' > webserver_ips.txt
        i=1
        while read -r ip; do
          if [ -n "$ip" ]; then
            cat >> ~/.ssh/config << EOF

        Host webserver${i}
          HostName ${ip}
          User ec2-user
          IdentityFile ~/.ssh/id_rsa
          ProxyJump bastion
          StrictHostKeyChecking no
          UserKnownHostsFile ~/.ssh/known_hosts
          ConnectTimeout 30
          ServerAliveInterval 60
        EOF
            i=$((i+1))
          fi
        done < webserver_ips.txt
        
        # Add a generic webserver alias pointing to the first instance
        first_ip=$(head -n1 webserver_ips.txt)
        cat >> ~/.ssh/config << EOF

        Host webserver
          HostName ${first_ip}
          User ec2-user
          IdentityFile ~/.ssh/id_rsa
          ProxyJump bastion
          StrictHostKeyChecking no
          UserKnownHostsFile ~/.ssh/known_hosts
          ConnectTimeout 30
          ServerAliveInterval 60
        EOF
        
        chmod 600 ~/.ssh/config
        [ -f ~/.ssh/known_hosts ] && chmod 644 ~/.ssh/known_hosts
        
        echo "SSH configuration created successfully:"
        cat ~/.ssh/config
        
        rm -f webserver_ips.txt
    
    - name: Wait for EC2 instances to be ready
      run: |
        echo "Waiting for ${{ needs.deploy-infrastructure.outputs.instance_count }} EC2 instances to be fully ready..."
        echo "Bastion IP: ${{ needs.deploy-infrastructure.outputs.bastion_ip }}"
        echo "Webserver private IPs: ${{ needs.deploy-infrastructure.outputs.web_instance_private_ips }}"
        sleep 60
    
    - name: Test SSH connectivity to all instances
      run: |
        echo "Testing bastion connection..."
        ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no bastion 'echo "✅ Bastion connection successful"' || {
          echo "❌ Bastion connection failed"
          exit 1
        }
        
        echo "Testing all webserver connections through bastion..."
        echo '${{ needs.deploy-infrastructure.outputs.web_instance_private_ips }}' | jq -r '.[]' > webserver_ips.txt
        i=1
        while read -r ip; do
          if [ -n "$ip" ]; then
            echo "Testing webserver${i} (${ip})..."
            ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no webserver${i} "echo '✅ Webserver${i} connection successful'" || {
              echo "❌ Webserver${i} connection failed"
              exit 1
            }
            i=$((i+1))
          fi
        done < webserver_ips.txt
        rm -f webserver_ips.txt
    
    - name: Install Ansible
      run: |
        sudo apt update
        sudo apt install -y ansible
    
    - name: Create dynamic Ansible inventory for all webservers
      working-directory: ./ec2-solution/ansible
      run: |
        # Generate dynamic inventory from Terraform outputs
        echo '[webservers]' > inventory
        echo '${{ needs.deploy-infrastructure.outputs.web_instance_private_ips }}' | jq -r '.[]' > webserver_ips.txt
        i=1
        while read -r ip; do
          if [ -n "$ip" ]; then
            echo "webserver${i} ansible_host=${ip} ansible_user=ec2-user ansible_ssh_common_args='-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ProxyJump=ec2-user@${{ needs.deploy-infrastructure.outputs.bastion_ip }}'" >> inventory
            i=$((i+1))
          fi
        done < webserver_ips.txt
        
        echo '' >> inventory
        echo '[bastions]' >> inventory
        echo "bastion ansible_host=${{ needs.deploy-infrastructure.outputs.bastion_ip }} ansible_user=ec2-user ansible_ssh_common_args='-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null'" >> inventory
        echo '' >> inventory
        echo '[all:vars]' >> inventory
        echo 'ansible_python_interpreter=/usr/bin/python3.8' >> inventory
        echo 'ansible_ssh_retries=3' >> inventory
        echo 'ansible_timeout=30' >> inventory
        echo 'ansible_stdout_callback=minimal' >> inventory
        echo 'ansible_stderr_callback=minimal' >> inventory
        
        echo "Generated dynamic Ansible inventory for ${{ needs.deploy-infrastructure.outputs.instance_count }} instances:"
        cat inventory
        
        # Cleanup
        rm -f webserver_ips.txt
    
    - name: Prepare all EC2 instances for Ansible
      run: |
        echo "Preparing all EC2 instances with required packages..."
        echo '${{ needs.deploy-infrastructure.outputs.web_instance_private_ips }}' | jq -r '.[]' > webserver_ips.txt
        i=1
        while read -r ip; do
          if [ -n "$ip" ]; then
            echo "Preparing webserver${i} (${ip})..."
            ssh webserver${i} 'sudo amazon-linux-extras enable python3.8 && sudo yum update -y && sudo yum install -y python38 python38-pip python38-setuptools' || {
              echo "Failed to prepare webserver${i}, but continuing..."
            }
            ssh webserver${i} 'sudo pip3.8 install --upgrade pip setuptools' || echo "Pip upgrade failed on webserver${i}, continuing..."
            ssh webserver${i} 'python3.8 --version && which python3.8' || echo "Python test failed on webserver${i}"
            i=$((i+1))
          fi
        done < webserver_ips.txt
        rm -f webserver_ips.txt
    
    - name: Test Ansible connectivity to all instances
      working-directory: ./ec2-solution/ansible
      run: |
        echo "Testing Ansible connectivity to all webservers..."
        ansible webservers -i inventory -m raw -a "echo 'Raw connection test successful'; python3.8 --version; echo 'Connectivity verified'" || {
          echo "❌ Raw connection failed"
          exit 1
        }
        echo "✅ Ansible connectivity test passed for all instances"
    
    - name: Deploy application with Ansible to all instances
      working-directory: ./ec2-solution/ansible
      env:
        ANSIBLE_PYTHON_INTERPRETER: /usr/bin/python3
        ANSIBLE_STDOUT_CALLBACK: minimal
        ANSIBLE_STDERR_CALLBACK: minimal
        ANSIBLE_HOST_KEY_CHECKING: false
        ANSIBLE_TIMEOUT: 30
      run: |
        echo "Deploying application with Ansible to ${{ needs.deploy-infrastructure.outputs.instance_count }} instances..."
        ansible-playbook -i inventory playbook.yml --skip-tags ssl --diff --timeout=300 -v -e "aws_region=${{ env.AWS_REGION }}"
        echo "✅ Deployed application successfully to all instances"

    # CRITICAL: Always remove the runner IP from security group
    - name: Remove runner IP from security group
      if: always()  # Run even if previous steps fail
      run: |
        echo "Removing runner IP ${{ steps.ip.outputs.ipv4 }} from security group ${{ needs.deploy-infrastructure.outputs.bastion_sg_id }}"
        aws ec2 revoke-security-group-ingress \
          --group-id ${{ needs.deploy-infrastructure.outputs.bastion_sg_id }} \
          --protocol tcp \
          --port 22 \
          --cidr ${{ steps.ip.outputs.ipv4 }}/32 || {
          echo "⚠️ Failed to remove IP from security group - this should be cleaned up manually"
        }
    
    - name: Verify multi-instance deployment
      run: |
        echo "🎉 Multi-instance deployment completed!"
        echo "Number of instances deployed: ${{ needs.deploy-infrastructure.outputs.instance_count }}"
        echo "Bastion Host: ${{ needs.deploy-infrastructure.outputs.bastion_ip }}"
        echo "Webserver IPs:"
        echo '${{ needs.deploy-infrastructure.outputs.web_instance_public_ips }}' | jq -r '.[]' | while read ip; do
          echo "  - http://${ip}"
        done

  notify-failure:
    needs: [deploy-infrastructure, deploy-application]
    runs-on: ubuntu-latest
    if: failure()
    
    steps:
    - name: Deployment Failure Notification
      run: |
        echo "❌ MULTI-INSTANCE DEPLOYMENT FAILED! ❌"
        echo "Please check the workflow logs for details."
        echo "Note: If deployment failed after IP whitelisting, the runner IP may still be in the security group."
        echo "Attempted to deploy ${{ needs.deploy-infrastructure.outputs.instance_count }} instances."