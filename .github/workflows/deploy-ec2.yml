name: Deploy Resume Website to EC2 (Dynamic IP)

on:
  push:
    branches: [ main ]
    paths:
      - 'ec2-solution/**'
      - '.github/workflows/deploy-ec2-dynamic-ip.yml'
  pull_request:
    branches: [ main ]
    paths:
      - 'ec2-solution/**'
      - '.github/workflows/deploy-ec2-dynamic-ip.yml'
  workflow_dispatch:  # Allow manual triggering

env:
  AWS_REGION: eu-west-1
  TERRAFORM_VERSION: 1.5.0

jobs:
  deploy-infrastructure:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    outputs:
      webserver_ip: ${{ steps.outputs.outputs.webserver_ip }}
      bastion_ip: ${{ steps.outputs.outputs.bastion_ip }}
      webserver_private_ip: ${{ steps.outputs.outputs.webserver_private_ip }}
      bastion_sg_id: ${{ steps.outputs.outputs.bastion_sg_id }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TERRAFORM_VERSION }}
        terraform_wrapper: false
    
    - name: Package Lambda functions
      working-directory: ./ec2-solution
      run: |
        cd lambda
        zip -r ../terraform/visitor_counter_lambda.zip visitor_counter_lambda.py
        zip -r ../terraform/contact_form_lambda.zip contact_form_lambda.py
        cd ..
        ls -la terraform/*.zip
    
    - name: Terraform Init
      working-directory: ./ec2-solution/terraform
      run: |
        terraform init \
          -backend-config="bucket=terraform-state-resume-website" \
          -backend-config="key=ec2-solution/terraform.tfstate" \
          -backend-config="region=eu-west-1" \
          -backend-config="dynamodb_table=terraform-state-lock"
    
    - name: Terraform Validate
      working-directory: ./ec2-solution/terraform
      run: terraform validate
    
    - name: Terraform Plan
      working-directory: ./ec2-solution/terraform
      run: |
        terraform plan -detailed-exitcode \
          -var="ami_id=${{ secrets.TF_AMI_ID }}" \
          -var="bastion_ami_id=${{ secrets.TF_BASTION_AMI_ID }}" \
          -var="domain_name=${{ secrets.TF_DOMAIN_NAME }}" \
          -var="key_name=${{ secrets.TF_KEY_NAME }}" \
          -var="management_cidr=${{ secrets.TF_MANAGEMENT_CIDR }}" \
          -var="public_key_content=${{ secrets.TF_PUBLIC_KEY }}"
      continue-on-error: true
      id: plan
    
    - name: Terraform Apply
      working-directory: ./ec2-solution/terraform
      if: github.ref == 'refs/heads/main'
      run: |
        terraform apply -auto-approve \
          -var="ami_id=${{ secrets.TF_AMI_ID }}" \
          -var="bastion_ami_id=${{ secrets.TF_BASTION_AMI_ID }}" \
          -var="domain_name=${{ secrets.TF_DOMAIN_NAME }}" \
          -var="key_name=${{ secrets.TF_KEY_NAME }}" \
          -var="management_cidr=${{ secrets.TF_MANAGEMENT_CIDR }}" \
          -var="public_key_content=${{ secrets.TF_PUBLIC_KEY }}"
    
    - name: Get Terraform Outputs
      working-directory: ./ec2-solution/terraform
      id: outputs
      run: |
        echo "webserver_ip=$(terraform output -raw instance_public_ip)" >> $GITHUB_OUTPUT
        echo "bastion_ip=$(terraform output -raw bastion_public_ip)" >> $GITHUB_OUTPUT
        echo "webserver_private_ip=$(terraform output -raw instance_private_ip)" >> $GITHUB_OUTPUT
        echo "bastion_sg_id=$(terraform output -raw bastion_security_group_id)" >> $GITHUB_OUTPUT

  deploy-application:
    needs: deploy-infrastructure
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    # Get the current runner's public IP
    - name: Get runner IP
      id: ip
      uses: haythem/public-ip@v1.2

    # Dynamically whitelist the runner IP
    - name: Whitelist runner IP
      run: |
        echo "Adding runner IP ${{ steps.ip.outputs.ipv4 }} to security group ${{ needs.deploy-infrastructure.outputs.bastion_sg_id }}"
        aws ec2 authorize-security-group-ingress \
          --group-id ${{ needs.deploy-infrastructure.outputs.bastion_sg_id }} \
          --protocol tcp \
          --port 22 \
          --cidr ${{ steps.ip.outputs.ipv4 }}/32
    
    - name: Setup SSH
      run: |
        mkdir -p ~/.ssh
        chmod 700 ~/.ssh
        
        printf '%s\n' "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        
        # Validate SSH key
        ssh-keygen -l -f ~/.ssh/id_rsa && echo "âœ… SSH key validation successful" || {
          echo "âŒ SSH key validation failed"
          exit 1
        }
    
    - name: Configure SSH connections
      run: |
        BASTION_IP=${{ needs.deploy-infrastructure.outputs.bastion_ip }}
        
        # Add bastion to known hosts with retry
        for i in {1..3}; do
          echo "Attempt $i: Scanning SSH keys for $BASTION_IP"
          if timeout 30 ssh-keyscan -H $BASTION_IP >> ~/.ssh/known_hosts 2>/dev/null; then
            echo "âœ… SSH keyscan successful"
            break
          else
            echo "âš ï¸ SSH keyscan attempt $i failed, retrying..."
            sleep 10
          fi
          
          if [ $i -eq 3 ]; then
            echo "âš ï¸ SSH keyscan failed after 3 attempts, proceeding without it"
          fi
        done
        
        # Create SSH config
        cat > ~/.ssh/config << EOF
        Host bastion
          HostName $BASTION_IP
          User ec2-user
          IdentityFile ~/.ssh/id_rsa
          StrictHostKeyChecking no
          UserKnownHostsFile ~/.ssh/known_hosts
          ConnectTimeout 30
          ServerAliveInterval 60

        Host webserver
          HostName ${{ needs.deploy-infrastructure.outputs.webserver_private_ip }}
          User ec2-user
          IdentityFile ~/.ssh/id_rsa
          ProxyJump bastion
          StrictHostKeyChecking no
          UserKnownHostsFile ~/.ssh/known_hosts
          ConnectTimeout 30
          ServerAliveInterval 60
        EOF
        
        chmod 600 ~/.ssh/config
        [ -f ~/.ssh/known_hosts ] && chmod 644 ~/.ssh/known_hosts
        
        echo "SSH configuration created successfully:"
        cat ~/.ssh/config
    
    - name: Wait for EC2 instances to be ready
      run: |
        echo "Waiting for EC2 instances to be fully ready..."
        echo "Bastion IP: ${{ needs.deploy-infrastructure.outputs.bastion_ip }}"
        echo "Webserver private IP: ${{ needs.deploy-infrastructure.outputs.webserver_private_ip }}"
        sleep 60
    
    - name: Test SSH connectivity
      run: |
        echo "Testing bastion connection..."
        ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no bastion 'echo "âœ… Bastion connection successful"' || {
          echo "âŒ Bastion connection failed"
          exit 1
        }
        
        echo "Testing webserver connection through bastion..."
        ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no webserver 'echo "âœ… Webserver connection successful"' || {
          echo "âŒ Webserver connection failed"
          exit 1
        }
    
    - name: Install Ansible
      run: |
        sudo apt update
        sudo apt install -y ansible
    
    - name: Create Ansible inventory
      working-directory: ./ec2-solution/ansible
      run: |
        cat > inventory << 'EOF'
        [webservers]
        webserver ansible_host=${{ needs.deploy-infrastructure.outputs.webserver_private_ip }} ansible_user=ec2-user ansible_ssh_common_args='-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ProxyJump=ec2-user@${{ needs.deploy-infrastructure.outputs.bastion_ip }}'

        [bastions]
        bastion ansible_host=${{ needs.deploy-infrastructure.outputs.bastion_ip }} ansible_user=ec2-user ansible_ssh_common_args='-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null'

        [all:vars]
        ansible_python_interpreter=/usr/bin/python3.8
        ansible_ssh_retries=3
        ansible_timeout=30
        ansible_stdout_callback=minimal
        ansible_stderr_callback=minimal
        EOF
        
        echo "Generated Ansible inventory:"
        cat inventory

    - name: Prepare EC2 instance for Ansible
      run: |
        echo "Preparing EC2 instance with required packages..."
        ssh webserver 'sudo amazon-linux-extras enable python3.8 && sudo yum update -y && sudo yum install -y python38 python38-pip python38-setuptools' || {
          echo "Failed to prepare EC2 instance, but continuing..."
        }
        
        ssh webserver 'sudo pip3.8 install --upgrade pip setuptools' || echo "Pip upgrade failed, continuing..."
        ssh webserver 'python3.8 --version && which python3.8' || echo "Python test failed"
    
    - name: Test Ansible connectivity
      working-directory: ./ec2-solution/ansible
      run: |
        echo "Testing Ansible connectivity to webserver..."
        ansible webservers -i inventory -m raw -a "echo 'Raw connection test successful'; python3.8 --version; echo 'Connectivity verified'" || {
          echo "âŒ Raw connection failed"
          exit 1
        }
        echo "âœ… Ansible connectivity test passed"
    
    - name: Deploy application with Ansible
      working-directory: ./ec2-solution/ansible
      env:
        ANSIBLE_PYTHON_INTERPRETER: /usr/bin/python3
        ANSIBLE_STDOUT_CALLBACK: minimal
        ANSIBLE_STDERR_CALLBACK: minimal
        ANSIBLE_HOST_KEY_CHECKING: false
        ANSIBLE_TIMEOUT: 30
      run: |
        echo "Deploying application with Ansible..."
        ansible-playbook -i inventory playbook.yml --skip-tags ssl --diff --timeout=300 -v -e "aws_region=${{ env.AWS_REGION }}"
        echo "âœ… Deployed application successfully"

    # ansible-playbook -i inventory playbook.yml --skip-tags ssl --diff --timeout=300 -v -e "aws_region=${{ env.AWS_REGION }}"

    # CRITICAL: Always remove the runner IP from security group
    - name: Remove runner IP from security group
      if: always()  # Run even if previous steps fail
      run: |
        echo "Removing runner IP ${{ steps.ip.outputs.ipv4 }} from security group ${{ needs.deploy-infrastructure.outputs.bastion_sg_id }}"
        aws ec2 revoke-security-group-ingress \
          --group-id ${{ needs.deploy-infrastructure.outputs.bastion_sg_id }} \
          --protocol tcp \
          --port 22 \
          --cidr ${{ steps.ip.outputs.ipv4 }}/32 || {
          echo "âš ï¸ Failed to remove IP from security group - this should be cleaned up manually"
        }
    
    - name: Verify deployment
      run: |
        echo "ðŸŽ‰ Deployment completed!"
        echo "Website URL: http://${{ needs.deploy-infrastructure.outputs.webserver_ip }}"
        echo "HTTPS URL: https://${{ needs.deploy-infrastructure.outputs.webserver_ip }} (self-signed)"
        echo "Bastion Host: ${{ needs.deploy-infrastructure.outputs.bastion_ip }}"

  notify-failure:
    needs: [deploy-infrastructure, deploy-application]
    runs-on: ubuntu-latest
    if: failure()
    
    steps:
    - name: Deployment Failure Notification
      run: |
        echo "âŒ DEPLOYMENT FAILED! âŒ"
        echo "Please check the workflow logs for details."
        echo "Note: If deployment failed after IP whitelisting, the runner IP may still be in the security group."